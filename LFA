# The title of the work

### Course: Formal Languages & Finite Automata
### Author: Name Surname (Preferably yours!)

----

## Theory
If needed, but it should be written by the author in her/his words.


## Objectives:

*Discover what a language is and what it needs to have in order to be considered a formal one;

*Provide the initial setup for the evolving project that you will work on during this semester. You can deal with each laboratory work as a separate task or project to demonstrate your understanding of the given themes, but you also can deal with labs as stages of making your own big solution, your own project. Do the following:

a. Create GitHub repository to deal with storing and updating your project;

b. Choose a programming language. Pick one that will be easiest for dealing with your tasks, you need to learn how to solve the problem itself, not everything around the problem (like setting up the project, launching it correctly and etc.);

c. Store reports separately in a way to make verification of your work simpler (duh)

*According to your variant number, get the grammar definition and do the following:

a. Implement a type/class for your grammar;

b. Add one function that would generate 5 valid strings from the language expressed by your given grammar;

c. Implement some functionality that would convert and object of type Grammar to one of type Finite Automaton;

d. For the Finite Automaton, please add a method that checks if an input string can be obtained via the state transition from it;


## Implementation description

* About 2-3 sentences to explain each piece of the implementation.


* Code snippets from your files.

```
import random
class Grammar:
    def __init__(self, VN, VT, P, S):
        self.VN = VN
        self.VT = VT
        self.P = P
        self.S = S

    def generateValidStrings(self, count):
        def generateFromSymbol(symbol):
            if symbol in self.VT:
                return symbol
            else:
                production = random.choice(self.P[symbol])
                return ''.join(generateFromSymbol(s) for s in production)

        valid_strings = []
        for _ in range(count):
            valid_strings.append(generateFromSymbol(self.S))
        return valid_strings

    def toFiniteAutomaton(self):
        Q = self.VN.union({'X'})  # States of the FA are the non-terminals of the grammar plus an additional state X
        Sigma = self.VT  # Alphabet of the FA is the set of terminals of the grammar
        Delta = {}  # Transition function
        q0 = {self.S}  # Initial state is the start symbol of the grammar
        F = {'X'}  # Set of final states

        # Initialize Delta with empty sets for all state-symbol pairs
        for state in Q:
            for symbol in Sigma:
                Delta[(state, symbol)] = set()

        # Construct transition function Delta
        for non_terminal, productions in self.P.items():
            for production in productions:
                if len(production) == 1 and production[0] in self.VT:  # Non-terminal to terminal transition
                    Delta[(non_terminal, production[0])].add('X')
                elif len(production) == 2 and production[0] in self.VT:  # Non-terminal to non-terminal transition
                    Delta[(non_terminal, production[0])].add(production[1])
                elif len(production) == 1 and production[0] in self.VN:  # Non-terminal to terminal transition
                    Delta[(non_terminal, '')].add(production[0])
                    F.add(production[0])  # Production is a final state

        return FiniteAutomaton(Q, Sigma, Delta, q0, F)


class FiniteAutomaton:
    def __init__(self, Q, Sigma, Delta, q0, F):
        self.Q = Q
        self.Sigma = Sigma
        self.Delta = Delta
        self.q0 = q0
        self.F = F

    def stringBelongToLanguage(self, w):
        currentStates = self.q0
        for letter in w:
            nextStates = set()
            for state in currentStates:
                if (state, letter) in self.Delta:
                    nextStates.update(self.Delta[(state, letter)])
            currentStates = nextStates
        return any(state in self.F for state in currentStates)


# Grammar variant 11
VN = {'S', 'B', 'D'}
VT = {'a', 'b', 'c'}
P = {
    'S': ['aB', 'bB'],
    'B': ['bD', 'cB', 'aS'],
    'D': ['b', 'aD']
}
S = 'S'

# Create an instance of Grammar
grammar = Grammar(VN, VT, P, S)

# Generate 5 valid strings
valid_strings = grammar.generateValidStrings(5)
print("Generated strings:")
for s in valid_strings:
    print(s)

print("-------------------------------------------------------------")

# Test Finite Automaton functionality
finiteAutomaton = grammar.toFiniteAutomaton()
listOfStrings = ["bbb", "ababab", "acaaaabb", "ababababab", "abb"]
for word in listOfStrings:
    print(f'{word} can be obtained via the state transition: {finiteAutomaton.stringBelongToLanguage(word)}')

```




## Results


## References
